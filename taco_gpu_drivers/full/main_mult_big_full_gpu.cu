#include <cuda_runtime.h>
#include <stdlib.h>
#include <stdio.h>
#include <stdint.h>
 #include <time.h>
#include "taco.h"
extern taco_tensor_t* init_taco_tensor(int32_t order, int32_t csize, int32_t* dimensions);
extern taco_tensor_t* init_taco_tensor_gpu(taco_tensor_t* ht);
extern void fill_array(float* arr, int len);
extern double calc_spent_time(struct timespec end, struct timespec start);
extern double average(double* values, int len);
extern void gpuAssert(cudaError_t code, const char *file, int line, bool abort=true);
#define gpuErrchk(ans) { gpuAssert((ans), __FILE__, __LINE__); }

#ifndef TACO_TENSOR_T_DEFINED
#define TACO_TENSOR_T_DEFINED
typedef enum { taco_mode_dense, taco_mode_sparse } taco_mode_t;
typedef struct {
  int32_t      order;         // 
  int32_t*     dimensions;    // 
  int32_t      csize;         // 
  int32_t*     mode_ordering; // 
  taco_mode_t* mode_types;    // 
  uint8_t***   indices;       // 
  float* vals          // 
  uint8_t*     fill_value;    // 
  int32_t      vals_size;     // 
} taco_tensor_t;
#endif

// Generated by the Tensor Algebra Compiler (tensor-compiler.org)

__global__
void computeDeviceKernel0(taco_tensor_t * __restrict__ a, taco_tensor_t * __restrict__ b, taco_tensor_t * __restrict__ c){
  int a2_dimension = (int)(a->dimensions[1]);
  float* __restrict__ a_vals = (float*)(a->vals);
  int b1_dimension = (int)(b->dimensions[0]);
  int b2_dimension = (int)(b->dimensions[1]);
  float* __restrict__ b_vals = (float*)(b->vals);
  int c1_dimension = (int)(c->dimensions[0]);
  int c2_dimension = (int)(c->dimensions[1]);
  float* __restrict__ c_vals = (float*)(c->vals);

  int32_t i78 = blockIdx.x;
  int32_t i79 = (threadIdx.x % (256));
  if (threadIdx.x >= 256) {
    return;
  }

  int32_t i = i78 * 256 + i79;
  if (i >= b1_dimension)
    return;

  for (int32_t k = 0; k < c1_dimension; k++) {
    int32_t kb = i * b2_dimension + k;
    for (int32_t j = 0; j < c2_dimension; j++) {
      int32_t ja = i * a2_dimension + j;
      int32_t jc = k * c2_dimension + j;
      a_vals[ja] = a_vals[ja] + b_vals[kb] * c_vals[jc];
    }
  }
}

int compute(taco_tensor_t *a, taco_tensor_t *b, taco_tensor_t *c) {
  int a1_dimension = (int)(a->dimensions[0]);
  int a2_dimension = (int)(a->dimensions[1]);
  float* __restrict__ a_vals = (float*)(a->vals);
  int b1_dimension = (int)(b->dimensions[0]);

  for (int32_t pa = 0; pa < (a1_dimension * a2_dimension); pa++) {
    a_vals[pa] = 0.0;
  }

  computeDeviceKernel0<<<(b1_dimension + 255) / 256, 256>>>(a, b, c);
  cudaDeviceSynchronize();
  return 0;
}

int main(int argc, char* argv[]){
  int n_runs = atoi(argv[1]);
  if(argc < 2){
    printf("Please specify number of executions!\n");
    exit(1);
  }
  srand(time(0));
  struct timespec start, end_orig, end_taco;
  double* orig_run_times = (double*)malloc(n_runs * sizeof(double));
  double* taco_run_times = (double*)malloc(n_runs * sizeof(double));
  int A_ROW = 1000;
  int A_COL = 1000;
  int B_ROW = 1000;
  int B_COL = 1000;
  float* a_matrix = (float*)malloc(1000 * 1000 * sizeof(float));
  float* b_matrix = (float*)malloc(1000 * 1000 * sizeof(float));
  float* c_matrix = (float*)malloc(1000 * 1000 * sizeof(float));

  int a_matrix_dims[2] = {1000,1000};
  taco_tensor_t* a_matrix_tt = init_taco_tensor(2, sizeof(float), a_matrix_dims);
  a_matrix_tt->vals = a_matrix;
  a_matrix_tt = init_taco_tensor_gpu(a_matrix_tt);
  int b_matrix_dims[2] = {1000,1000};
  taco_tensor_t* b_matrix_tt = init_taco_tensor(2, sizeof(float), b_matrix_dims);
  b_matrix_tt->vals = b_matrix;
  b_matrix_tt = init_taco_tensor_gpu(b_matrix_tt);
  int c_matrix_dims[2] = {1000,1000};
  taco_tensor_t* c_matrix_tt = init_taco_tensor(2, sizeof(float), c_matrix_dims);
  c_matrix_tt->vals = c_matrix;
  c_matrix_tt = init_taco_tensor_gpu(c_matrix_tt);

  for(int i = 0; i < n_runs; i++){
    fill_array(a_matrix, 1000 * 1000);
    fill_array(b_matrix, 1000 * 1000);
    fill_array(c_matrix, 1000 * 1000);

    clock_gettime(CLOCK_MONOTONIC, &start);
// mult_big(A_ROW, A_COL, B_ROW, B_COL, a_matrix, b_matrix, c_matrix);
    clock_gettime(CLOCK_MONOTONIC, &end_orig);

    compute(a_matrix_tt, b_matrix_tt, c_matrix_tt);
    clock_gettime(CLOCK_MONOTONIC, &end_taco);

    orig_run_times[i] = calc_spent_time(end_orig, start);
    taco_run_times[i] = calc_spent_time(end_taco, end_orig);
  }

  double orig_time = average(orig_run_times, n_runs);
  double taco_time = average(taco_run_times, n_runs);
  printf("%.5lf %.5lf", orig_time, taco_time);
  return 0;
}
