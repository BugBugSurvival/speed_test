#include <cuda_runtime.h>
#include <stdlib.h>
#include <stdio.h>
#include <stdint.h>
#include <time.h>
#include "taco.h"

extern taco_tensor_t* init_taco_tensor(int32_t order, int32_t csize, int32_t* dimensions);
extern taco_tensor_t* init_taco_tensor_gpu(taco_tensor_t* ht);
extern void fill_array(int* arr, int len);
extern double calc_spent_time(struct timespec end, struct timespec start);
extern double average(double* values, int len);
extern void gpuAssert(cudaError_t code, const char *file, int line, bool abort=true);
#define gpuErrchk(ans) { gpuAssert((ans), __FILE__, __LINE__); }

#ifndef TACO_TENSOR_T_DEFINED
#define TACO_TENSOR_T_DEFINED
typedef enum { taco_mode_dense, taco_mode_sparse } taco_mode_t;
typedef struct {
    int32_t      order;         
    int32_t*     dimensions;    
    int32_t      csize;         
    int32_t*     mode_ordering; 
    taco_mode_t* mode_types;    
    uint8_t***   indices;       
    int*         vals;          
    uint8_t*     fill_value;    
    int32_t      vals_size;     
} taco_tensor_t;
#endif

// Generated by the Tensor Algebra Compiler (tensor-compiler.org)

__global__
void computeDeviceKernel0(taco_tensor_t * __restrict__ a, taco_tensor_t * __restrict__ b, taco_tensor_t * __restrict__ c, taco_tensor_t * __restrict__ d){
  int a2_dimension = (int)(a->dimensions[1]);
  float* __restrict__ a_vals = (float*)(a->vals);
  int b1_dimension = (int)(b->dimensions[0]);
  int b2_dimension = (int)(b->dimensions[1]);
  float* __restrict__ b_vals = (float*)(b->vals);
  int c1_dimension = (int)(c->dimensions[0]);
  int c2_dimension = (int)(c->dimensions[1]);
  float* __restrict__ c_vals = (float*)(c->vals);
  int d1_dimension = (int)(d->dimensions[0]);
  int d2_dimension = (int)(d->dimensions[1]);
  float* __restrict__ d_vals = (float*)(d->vals);

  int32_t i106 = blockIdx.x;
  int32_t i107 = (threadIdx.x % (256));
  if (threadIdx.x >= 256) {
    return;
  }

  int32_t i = i106 * 256 + i107;
  if (i >= b1_dimension)
    return;

  for (int32_t l = 0; l < c1_dimension; l++) {
    int32_t lb = i * b2_dimension + l;
    for (int32_t k = 0; k < d1_dimension; k++) {
      int32_t kc = l * c2_dimension + k;
      for (int32_t j = 0; j < d2_dimension; j++) {
        int32_t ja = i * a2_dimension + j;
        int32_t jd = k * d2_dimension + j;
        a_vals[ja] = a_vals[ja] + (b_vals[lb] * c_vals[kc]) * d_vals[jd];
      }
    }
  }
}

int compute(taco_tensor_t *a, taco_tensor_t *b, taco_tensor_t *c, taco_tensor_t *d) {
  int a1_dimension = (int)(a->dimensions[0]);
  int a2_dimension = (int)(a->dimensions[1]);
  float* __restrict__ a_vals = (float*)(a->vals);
  

int main(int argc, char* argv[]) {
    if (argc < 2) {
        printf("Please specify the number of runs.\n");
        exit(1);
    }

    int n_runs = atoi(argv[1]);
    srand(time(0));
    int N = 1000
    
    struct timespec start, end_orig, end_taco;
    double* orig_run_times = (double*)malloc(n_runs * sizeof(double));
    double* taco_run_times = (double*)malloc(n_runs * sizeof(double));
    
    int* block = (int*)malloc(N * N * sizeof(int));
    int* cos1 = (int*)malloc(N * N * sizeof(int));
    int* cos2 = (int*)malloc(N * N * sizeof(int));
    int* temp2d = (int*)malloc(N * N * sizeof(int));

    int block_dims[2] = {N, N};
    taco_tensor_t* block_tt = init_taco_tensor(2, sizeof(int), block_dims);
    block_tt->vals = block;
    block_tt = init_taco_tensor_gpu(block_tt);

    int cos1_dims[2] = {N, N};
    taco_tensor_t* cos1_tt = init_taco_tensor(2, sizeof(int), cos1_dims);
    cos1_tt->vals = cos1;
    cos1_tt = init_taco_tensor_gpu(cos1_tt);

    int cos2_dims[2] = {N, N};
    taco_tensor_t* cos2_tt = init_taco_tensor(2, sizeof(int), cos2_dims);
    cos2_tt->vals = cos2;
    cos2_tt = init_taco_tensor_gpu(cos2_tt);

    int temp2d_dims[2] = {N, N};
    taco_tensor_t* temp2d_tt = init_taco_tensor(2, sizeof(int), temp2d_dims);
    temp2d_tt->vals = temp2d;
    temp2d_tt = init_taco_tensor_gpu(temp2d_tt);

    for (int i = 0; i < n_runs; i++) {
        fill_array(block, N * N);
        fill_array(cos1, N * N);
        fill_array(cos2, N * N);
        fill_array(temp2d, N * N);

        clock_gettime(CLOCK_MONOTONIC, &start);
        // Call to the original CPU DCT implementation can be placed here if needed
        clock_gettime(CLOCK_MONOTONIC, &end_orig);

        compute_dct(block_tt, cos1_tt, cos2_tt, temp2d_tt);
        clock_gettime(CLOCK_MONOTONIC, &end_taco);

        orig_run_times[i] = calc_spent_time(end_orig, start);
        taco_run_times[i] = calc_spent_time(end_taco, end_orig);
    }

    double orig_time = average(orig_run_times, n_runs);
    double taco_time = average(taco_run_times, n_runs);
    printf("%.5lf %.5lf", orig_time, taco_time);

    free(block);
    free(cos1);
    free(cos2);
    free(temp2d);
    return 0;
}

